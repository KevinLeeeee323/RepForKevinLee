'''
[问题描述]
    一个集合 U = {1, 2, 3, ..., m}(干旱区的 m 个城市)
    一个集合族 S = {S₁, S₂, ..., Sₙ},其中每个 Sᵢ ⊆ U(第 i 个蓄水厂能覆盖的干旱城市集合)

    目标：选择最少的 Sᵢ,使得这些 Sᵢ 的并集等于 U(覆盖所有元素)

[具体例子]
    假设：
    U = {1, 2, 3, 4, 5}(5个干旱城市)
    S₁ = {1, 2, 3}
    S₂ = {2, 4}  
    S₃ = {3, 4, 5}
    S₄ = {1, 5}
    问题：选最少的集合覆盖所有 1~5 号城市。


[请你思考]
    1. 贪心策略：每次选择哪个集合？为什么？
    2. 这个策略总是最优的吗？能否构造反例？
    3. 时间复杂度如何？
    4. 如何实现这个贪心算法？
'''


'''
先考虑一定能够覆盖到的情况. 存在覆盖不到的情况先不考虑.

最著名的集合覆盖贪心算法是： 每次选择能覆盖最多未覆盖元素的集合
被称为Greedy Set Cover Algorithm
发展历程:1974年由 David S. Johnson 在论文《Approximation algorithms for combinatorial problems》中首次证明; 
        1975年 László Lovász 也独立给出了类似分析
        (以上待考证)


我的想法:
按照长度对这些集合进行降序排序
然后从长度最长的开始选, 边选边维护一个统计覆盖情况的数组. 如果选了这个之后, 未覆盖到的元素个数没有减少, 那就不选. 如果有减少, 那就选.
'''

