# %%
import numpy as np

# %%
def build_adjM(vertexNum:int, edges:list[tuple[int, int, int]])->np.ndarray:
    vertex_id=[i for i in range(vertexNum)]
    adjM=np.zeros(shape=(vertexNum, vertexNum))

    # 不用numpy库实现 adjM 创建: adjM=[[0 for _ in range(numCourses)] for _ in range(numCourses)]

    for (u, v, weight) in edges:
        adjM[u, v]=adjM[v, u]=weight # 无向有权图

    return adjM

# %%
def Prim(adjM:np.ndarray)->tuple[set[tuple[int, int]], int]:
    verNum=adjM.shape[0]

    selected=set()

    min_wei=np.full(shape=verNum, fill_value=np.inf, dtype=np.int16) #min_wei[u]=w 表示V_A中的顶点到V-V_A中的顶点的最小边权值
    pred=np.zeros(verNum, dtype=np.int16) #  min_wei[u]=w 对应的前驱结点

    minumum_spanning_tree=set()
    mst_weight=0

    selected.add(0)
    pred[0]=-1

    def update(): # 更新此时最小的轻边以及对应的最小生成树中的边
        for u in range(verNum):
            if u not in selected:
                for v in selected:
                    if adjM[v, u]<min_wei[u]:
                        min_wei[u]=adjM[v, u]
                        pred[u]=v

    
    for _ in range(verNum-1):
        update()
        min_weight=np.inf
        u_key=0
        for u in range(verNum):
            if u not in selected:
                if min_wei[u]<min_weight:
                    min_weight=min_wei[u]
                    u_key=u
        minumum_spanning_tree.add((pred[u_key], u_key))
        mst_weight+=adjM[pred[u_key], u_key]
        selected.add(u_key)
       

    return minumum_spanning_tree, mst_weight

# %% [markdown]
# ![Test Pic 1](MST_test1.png)

# %%
if __name__=='__main__':
    # 测试例子(如上图)来自 PPT P61, 结点字符已经转换成了对应的 id 编号在结点旁边
    vertexNum=9
    edges=[(0, 1, 4), (0, 4, 8), (1, 4, 1), (1, 2, 8), (2, 3, 7),
           (3, 8, 9), (7, 8, 10), (6, 7, 2), (4, 6, 1), (4, 5, 7),
           (2, 5, 2), (5, 6, 4), (2, 7, 4), (3, 7, 14)]
    
    adjM=build_adjM(vertexNum, edges)
    minimum_spanning_tree, mst_weight=Prim(adjM)
    print(minimum_spanning_tree, mst_weight)

# %%



